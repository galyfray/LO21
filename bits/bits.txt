
Definition du type Bits
#Type Bits
#constructeur:
#|bits_rinit:->Bits,céer et initalise l'élément Bits avec aléatoirement pour valeur 0 ou 1 sans suivant
#Observateurs et fonctions d’accès
#|bits_val  :Bits -> Bit  ,permet d'accédé a la valeur de Bits
#|bits_next :Bits -> Bits ,permet d'accédé a l'élément suivant
#Fin Type

Definition du type BitsList:
#Type BitsList(Bits)
#constructeur:
#|créer             :                 ->BitsList, créer une liste vide
#|bitslist_ajoutert : BitsList x Bits ->BitsList, ajoute un Bits en tête de liste
#|bitslist_ajouterq : BitsList x Bits ->BitsList, ajoute un Bits en fin de liste
#Observateurs et fonctions d’accès
#|bitslist_head :BitsList -> Bits   ,permet d'accédé a la première place de la liste
#|bitslist_toint:BitsList -> entier ,décode la liste de Bits et donne la valeur entère correspondante
#Fin Type

Données:
lenth un entier décrivant la longeur de la liste chainer de Bits a produire
Résultat:
liste une BitsList

fonction bitslist_rinit(entier lenth) BitsList //itérative
Début
|BitsList liste <- créer()
|pour i de 1 à lenth faire
||liste<-bitslist_ajoutert(liste,bits_rinit())
|fait
|bitslist_rinit<-liste
Fin

fonction bitslist_rinit(entier lenth) BitsList //récurcive
Début
|Si lenth <= 0 alors
||bitslist_rinit <- créer()
|Sinon
||bitslist_rinit <- bitslist_ajouterq(bits_rinit(lenth-1),bit_rinit())
|Fin Si
Fin

Données
liste un Bits dont ont doit décodée la valeur les Bits le composant sont ranger par ordre de puissance croissante
Résultat
value un entier valeur extraite de liste

fonction bitslist_toint(BitsList liste) entier
Début
|entier pow <- 1
|entier value <- 0
|Bits elem <-bits_head(liste)
|tant que elem /= indéfini faire 
||value <- value + pow*bits_val(elem)
||pow <- pow*2
||elem <- bits_next(elem)
|Fait
|bitslist_toint <- value
Fin

Données
L1,L2 les BitList a croisé de même longueur
pCroise : la probabilité de croisement, compris entre 0 et 1,
résultat 
L3 une BitsList tel qu'il y ai pCroise chance a chaque élément de L3 qu'il provienne de L2
Lexique
B1 un Bits élément de L1
B2 un Bits élément de L2
Aléat : fonction générant un réel aléatoire compris entre les deux borne qui lui sont donné en paramètre

fonction crossBreed(Bitslist L1,Bitslist L2 ,Réel pCroise) BitsList
Début 
|BitsList L3 = créer()
|Bits B1<-tete(L1)
|Bits B2<-tete(L2)
|tant que B1/=indéfini faire:
||Si Aléat(0,1)>pCroise Alors
|||ajouterq(L3,B1)
||Sinon
|||L3<-bitslist_ajouterq(L3,B2)
||Fin Si
||B1<-suivant(B1)
||B2<-suivant(B2)
|Fait
|crossBreed<-L3
Fin

Données
A,B deux entier paramètre
Value un entier représentant la valeur d'un individu
Lenth un entier représente la longueur d'un individu
Résultat:
quality un réel la qualité de l'individu
Lexique
i un entier un compteur
P un entier permet de calculer 2^lenth
 
fonction quality(entier Value,Réel A,Réel B,entier lenth) Réel
Début
|entier i,P=1
|pour i de 1 à lenth faire
||P=2*P
|fait
|réel X<-(x/P)*(B-A)+A
|quality<-(-X)*X
Fin
